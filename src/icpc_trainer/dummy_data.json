{
  "weeks": [
    {
      "week": "Week 1 - Greedy Warmup",
      "problems": [
        {
          "id": "A",
          "status": "solved",
          "description": "# Problem A: Coin Rows\n\nGiven a row of coins with values, choose a subset of non-adjacent coins to maximize total value.\n\n## Input\n- First line: integer `n`\n- Second line: `n` integers\n\n## Output\n- Maximum sum\n\n## Notes\nUse dynamic programming with state `dp[i]` as best up to index `i`."
        },
        {
          "id": "B",
          "status": "attempted",
          "description": "# Problem B: Server Allocation\n\nYou are given jobs with deadlines and profits. Each job takes one unit time.\n\n## Goal\nSchedule jobs to maximize profit before deadlines.\n\n## Hint\nSort jobs by profit and place each job at the latest possible free slot."
        },
        {
          "id": "C",
          "status": "unsolved",
          "description": "# Problem C: Balanced Brackets++\n\nFor each query string, determine if it can become balanced by changing at most one character.\n\n## Constraints\n- Up to `2e5` total characters across test cases\n\n## Direction\nThink in terms of prefix balance and early invalid states."
        }
      ]
    },
    {
      "week": "Week 2 - Graph Basics",
      "problems": [
        {
          "id": "A",
          "status": "attempted",
          "description": "# Problem A: City Reachability\n\nGiven a directed graph, answer whether city `u` can reach city `v` for multiple queries.\n\n## Idea\nFor sparse queries, run BFS/DFS per query. For many queries, consider transitive closure tradeoffs."
        },
        {
          "id": "B",
          "status": "unsolved",
          "description": "# Problem B: Shortest Relay\n\nFind shortest path from `s` to `t` with non-negative edge weights.\n\n## Output\nDistance and one valid shortest path.\n\n## Hint\nUse Dijkstra with parent reconstruction."
        },
        {
          "id": "C",
          "status": "unsolved",
          "description": "# Problem C: Team Components\n\nGiven an undirected graph with `n` members, output the size of each connected component in ascending order.\n\n## Tip\nTrack visited nodes and run DFS/BFS from every unvisited node."
        }
      ]
    },
    {
      "week": "Week 3 - Strings",
      "problems": [
        {
          "id": "A",
          "status": "solved",
          "description": "# Problem A: Prefix Match\n\nFor each pattern, count occurrences in text.\n\n## Direction\nImplement KMP prefix-function for linear scanning."
        },
        {
          "id": "B",
          "status": "attempted",
          "description": "# Problem B: Minimal Rotation\n\nReturn lexicographically minimal cyclic rotation of a string.\n\n## Hint\nBooth's algorithm works in linear time."
        },
        {
          "id": "C",
          "status": "unsolved",
          "description": "# Problem C: Substring Queries\n\nSupport online queries asking if a pattern appears in dynamic text after point updates.\n\n## Challenge\nBalance update/query complexity using rolling hash or segment structures."
        }
      ]
    }
  ]
}
